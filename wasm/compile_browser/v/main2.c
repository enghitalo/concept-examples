
#ifndef V_COMMIT_HASH
	#define V_COMMIT_HASH "d3ed3614633d2ee351446d88f48914894e05b3f3"
#endif

#define V_USE_SIGNAL_H

// V comptime_definitions:
// V compile time defines by -d or -define flags:
//     All custom defines      : linux
//     Turned ON custom defines: linux
#define CUSTOM_DEFINE_linux


// V typedefs:

// BEGIN_multi_return_typedefs
// END_multi_return_typedefs

typedef struct builtin__closure__Closure builtin__closure__Closure;
typedef struct builtin__closure__ClosureMutex builtin__closure__ClosureMutex;
typedef struct array array;
typedef struct string string;

 // V preincludes:

#if defined(__TINYC__) && defined(__has_include)
// tcc does not support has_include properly yet, turn it off completely
#undef __has_include
#endif

// V cheaders:
// Generated by the V compiler

#if defined __GNUC__ && __GNUC__ >= 14
#pragma GCC diagnostic warning "-Wimplicit-function-declaration"
#pragma GCC diagnostic warning "-Wincompatible-pointer-types"
#pragma GCC diagnostic warning "-Wint-conversion"
#pragma GCC diagnostic warning "-Wreturn-mismatch"
#endif

#define _GNU_SOURCE

#if defined(__TINYC__) && defined(__has_include)
// tcc does not support has_include properly yet, turn it off completely
#undef __has_include
#endif

#if defined(__has_include)

#if __has_include(<inttypes.h>)
#include <inttypes.h>
#else
#error VERROR_MESSAGE The C compiler can not find <inttypes.h>. Please install the package `build-essential`.
#endif

#else
#include <inttypes.h>
#endif


#if defined(__has_include)

#if __has_include(<stddef.h>)
#include <stddef.h>
#else
#error VERROR_MESSAGE The C compiler can not find <stddef.h>. Please install the package `build-essential`.
#endif

#else
#include <stddef.h>
#endif


//================================== builtin types ================================*/
#if defined(__x86_64__) || defined(_M_AMD64) || defined(__aarch64__) || defined(__arm64__) || defined(_M_ARM64) || (defined(__riscv_xlen) && __riscv_xlen == 64) || defined(__s390x__) || (defined(__powerpc64__) && defined(__LITTLE_ENDIAN__)) || defined(__loongarch64)
typedef int64_t vint_t;
#else
typedef int32_t vint_t;
#endif
typedef int64_t i64;
typedef int16_t i16;
typedef int8_t i8;
typedef uint64_t u64;
typedef uint32_t u32;
typedef uint8_t u8;
typedef uint16_t u16;
typedef u8 byte;
typedef int32_t i32;
typedef uint32_t rune;
typedef size_t usize;
typedef ptrdiff_t isize;
#ifndef VNOFLOAT
typedef float f32;
typedef double f64;
#else
typedef int32_t f32;
typedef int64_t f64;
#endif
typedef int64_t int_literal;
#ifndef VNOFLOAT
typedef double float_literal;
#else
typedef int64_t float_literal;
#endif
typedef unsigned char* byteptr;
typedef void* voidptr;
typedef char* charptr;
typedef u8 array_fixed_byte_300 [300];
typedef struct sync__Channel* chan;
#ifndef CUSTOM_DEFINE_no_bool
	#ifndef __cplusplus
		#ifndef bool
			#ifdef CUSTOM_DEFINE_4bytebool
				typedef int bool;
			#else
				typedef u8 bool;
			#endif
			#define true 1
			#define false 0
		#endif
	#endif
#endif

//============================== HELPER C MACROS =============================*/
// _SLIT0 is used as NULL string for literal arguments
// `"" s` is used to enforce a string literal argument
#define _SLIT0 (string){.str=(byteptr)(""), .len=0, .is_lit=1}
#define _S(s) ((string){.str=(byteptr)("" s), .len=(sizeof(s)-1), .is_lit=1})
#define _SLEN(s, n) ((string){.str=(byteptr)("" s), .len=n, .is_lit=1})
// optimized way to compare literal strings
#define _SLIT_EQ(sptr, slen, lit) (slen == sizeof("" lit)-1 && !builtin__vmemcmp(sptr, "" lit, slen))
#define _SLIT_NE(sptr, slen, lit) (slen != sizeof("" lit)-1 || builtin__vmemcmp(sptr, "" lit, slen))
// take the address of an rvalue
#define ADDR(type, expr) (&((type[]){expr}[0]))
// copy something to the heap
#define HEAP(type, expr) ((type*)builtin__memdup((void*)&((type[]){expr}[0]), sizeof(type)))
#define HEAP_noscan(type, expr) ((type*)builtin__memdup_noscan((void*)&((type[]){expr}[0]), sizeof(type)))
#define HEAP_align(type, expr, align) ((type*)builtin__memdup_align((void*)&((type[]){expr}[0]), sizeof(type), align))
#define _PUSH_MANY(arr, val, tmp, tmp_typ) {tmp_typ tmp = (val); builtin__array_push_many(arr, tmp.data, tmp.len);}
#define _PUSH_MANY_noscan(arr, val, tmp, tmp_typ) {tmp_typ tmp = (val); builtin__array_push_many_noscan(arr, tmp.data, tmp.len);}

#define E_STRUCT_DECL
#define E_STRUCT
#define __NOINLINE __attribute__((noinline))
#define __IRQHANDLER __attribute__((interrupt))
#define __V_architecture 0
#if defined(__x86_64__) || defined(_M_AMD64)
	#define __V_amd64  1
	#undef __V_architecture
	#define __V_architecture 1
#endif
#if defined(__aarch64__) || defined(__arm64__) || defined(_M_ARM64)
	#define __V_arm64  1
	#undef __V_architecture
	#define __V_architecture 2
#endif
#if defined(__arm__) || defined(_M_ARM)
	#define __V_arm32  1
	#undef __V_architecture
	#define __V_architecture 3
#endif
#if defined(__riscv) && __riscv_xlen == 64
	#define __V_rv64  1
	#undef __V_architecture
	#define __V_architecture 4
#endif
#if defined(__riscv) && __riscv_xlen == 32
	#define __V_rv32  1
	#undef __V_architecture
	#define __V_architecture 5
#endif
#if defined(__i386__) || defined(_M_IX86)
	#define __V_x86    1
	#undef __V_architecture
	#define __V_architecture 6
#endif
#if defined(__s390x__)
	#define __V_s390x  1
	#undef __V_architecture
	#define __V_architecture 7
#endif
#if defined(__powerpc64__) && defined(__LITTLE_ENDIAN__)
	#define __V_ppc64le  1
	#undef __V_architecture
	#define __V_architecture 8
#endif
#if defined(__loongarch64)
	#define __V_loongarch64  1
	#undef __V_architecture
	#define __V_architecture 9
#endif
// Using just __GNUC__ for detecting gcc, is not reliable because other compilers define it too:
#ifdef __GNUC__
	#define __V_GCC__
#endif
#ifdef __TINYC__
	#undef __V_GCC__
#endif
#ifdef __cplusplus
	#undef __V_GCC__
#endif
#ifdef __clang__
	#undef __V_GCC__
#endif
#ifdef _MSC_VER
	#undef __V_GCC__
	#undef E_STRUCT_DECL
	#undef E_STRUCT
	#define E_STRUCT_DECL unsigned char _dummy_pad
	#define E_STRUCT 0
#endif
#ifndef _WIN32
	#if defined __has_include
		#if __has_include (<execinfo.h>)
			#include <execinfo.h>
		#else
			// On linux: int backtrace(void **__array, int __size);
			// On BSD: size_t backtrace(void **, size_t);
		#endif
	#endif
#endif
#ifdef __TINYC__
	#define _Atomic volatile
	#undef E_STRUCT_DECL
	#undef E_STRUCT
	#define E_STRUCT_DECL unsigned char _dummy_pad
	#define E_STRUCT 0
	#undef __NOINLINE
	#undef __IRQHANDLER
	// tcc does not support inlining at all
	#define __NOINLINE
	#define __IRQHANDLER
	// #include <byteswap.h>
	int tcc_backtrace(const char *fmt, ...);
#endif
// Use __offsetof_ptr instead of __offset_of, when you *do* have a valid pointer, to avoid UB:
#ifndef __offsetof_ptr
	#define __offsetof_ptr(ptr,PTYPE,FIELDNAME) ((size_t)((byte *)&((PTYPE *)ptr)->FIELDNAME - (byte *)ptr))
#endif
// for __offset_of
#ifndef __offsetof
#if defined(__TINYC__) || defined(_MSC_VER)
	#define __offsetof(PTYPE,FIELDNAME) ((size_t)(&((PTYPE *)0)->FIELDNAME))
#else
	#define __offsetof(st, m) __builtin_offsetof(st, m)
#endif
#endif
#if defined(_WIN32) || defined(__CYGWIN__)
	#define VV_EXP extern __declspec(dllexport)
	#define VV_LOC static
#else
	// 4 < gcc < 5 is used by some older Ubuntu LTS and Centos versions,
	// and does not support __has_attribute(visibility) ...
	#ifndef __has_attribute
		#define __has_attribute(x) 0  // Compatibility with non-clang compilers.
	#endif
	#if (defined(__GNUC__) && (__GNUC__ >= 4)) || (defined(__clang__) && __has_attribute(visibility))
		#ifdef ARM
			#define VV_EXP  extern __attribute__((externally_visible,visibility("default")))
		#else
			#define VV_EXP  extern __attribute__((visibility("default")))
		#endif
		#if defined(__clang__) && (defined(_VUSECACHE) || defined(_VBUILDMODULE))
			#define VV_LOC static
		#else
			#define VV_LOC  __attribute__ ((visibility ("hidden")))
		#endif
	#else
		#define VV_EXP extern
		#define VV_LOC static
	#endif
#endif
#ifdef __cplusplus
	#include <utility>
	#define _MOV std::move
#else
	#define _MOV
#endif
// tcc does not support has_include properly yet, turn it off completely
#if defined(__TINYC__) && defined(__has_include)
#undef __has_include
#endif
//likely and unlikely macros
#if defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__clang__)
	#define _likely_(x)  __builtin_expect(x,1)
	#define _unlikely_(x)  __builtin_expect(x,0)
#else
	#define _likely_(x) (x)
	#define _unlikely_(x) (x)
#endif

// c_headers
typedef int (*qsort_callback_func)(const void*, const void*);
#include <stdio.h>  // TODO: remove all these includes, define all function signatures and types manually
#include <stdlib.h>
#include <string.h>
#include <stdarg.h> // for va_list
#ifdef __TERMUX__
#if defined __BIONIC_AVAILABILITY_GUARD && __BIONIC_AVAILABILITY_GUARD(28)
#else
void * aligned_alloc(size_t alignment, size_t size) { return malloc(size); }
#endif
#endif
//================================== GLOBALS =================================*/
void _vinit(int ___argc, voidptr ___argv);
void _vcleanup(void);
#ifdef _WIN32
	// workaround for windows, export _vinit_caller/_vcleanup_caller, let dl.open()/dl.close() call it
	// NOTE: This is hardcoded in vlib/dl/dl_windows.c.v!
	VV_EXP void _vinit_caller();
	VV_EXP void _vcleanup_caller();
#endif
#define sigaction_size sizeof(sigaction);
#define _ARR_LEN(a) ( (sizeof(a)) / (sizeof(a[0])) )
#if INTPTR_MAX == INT32_MAX
	#define TARGET_IS_32BIT 1
#elif INTPTR_MAX == INT64_MAX
	#define TARGET_IS_64BIT 1
#else
	#error "The environment is not 32 or 64-bit."
#endif
#if defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__ || defined(__BYTE_ORDER) && __BYTE_ORDER == __BIG_ENDIAN || defined(__BIG_ENDIAN__) || defined(__ARMEB__) || defined(__THUMBEB__) || defined(__AARCH64EB__) || defined(_MIBSEB) || defined(__MIBSEB) || defined(__MIBSEB__)
	#define TARGET_ORDER_IS_BIG 1
#elif defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__ || defined(__BYTE_ORDER) && __BYTE_ORDER == __LITTLE_ENDIAN || defined(__LITTLE_ENDIAN__) || defined(__ARMEL__) || defined(__THUMBEL__) || defined(__AARCH64EL__) || defined(_MIPSEL) || defined(__MIPSEL) || defined(__MIPSEL__) || defined(_M_AMD64) || defined(_M_ARM64) || defined(_M_X64) || defined(_M_IX86)
	#define TARGET_ORDER_IS_LITTLE 1
#else
	#error "Unknown architecture endianness"
#endif
#ifndef _WIN32
	#include <ctype.h>
	#include <locale.h> // tolower
	#include <sys/time.h>
	#include <unistd.h> // sleep
	extern char **environ;
#endif
#if defined(__CYGWIN__) && !defined(_WIN32)
	#error Cygwin is not supported, please use MinGW or Visual Studio.
#endif
#if defined(__linux__) || defined(__APPLE__) || defined(__FreeBSD__) || defined(__DragonFly__) || defined(__vinix__) || defined(__serenity__) || defined(__sun) || defined(__plan9__)
	#include <sys/types.h>
	#include <sys/wait.h> // os__wait uses wait on nix
#endif
#ifdef __OpenBSD__
	#include <sys/types.h>
	#include <sys/resource.h>
	#include <sys/wait.h> // os__wait uses wait on nix
#endif
#ifdef __FreeBSD__
	#include <signal.h>
	#include <execinfo.h>
#endif
#ifdef __NetBSD__
	#include <sys/wait.h> // os__wait uses wait on nix
#endif
#ifdef _WIN32
	#define WINVER 0x0600
	#ifdef _WIN32_WINNT
		#undef _WIN32_WINNT
	#endif
	#define _WIN32_WINNT 0x0600
	#ifndef WIN32_FULL
	#define WIN32_LEAN_AND_MEAN
	#endif
	#ifndef _UNICODE
	#define _UNICODE
	#endif
	#ifndef UNICODE
	#define UNICODE
	#endif
	#include <windows.h>
	#include <io.h> // _waccess
	#include <direct.h> // _wgetcwd
	#ifdef V_USE_SIGNAL_H
	#include <signal.h> // signal and SIGSEGV for segmentation fault handler
	#endif
	#ifdef _MSC_VER
		// On MSVC these are the same (as long as /volatile:ms is passed)
		#define _Atomic volatile
		// MSVC cannot parse some things properly
		#undef __NOINLINE
		#undef __IRQHANDLER
		#define __NOINLINE __declspec(noinline)
		#define __IRQHANDLER __declspec(naked)
		#include <dbghelp.h>
		#pragma comment(lib, "Dbghelp")
	#endif
#else
	#include <pthread.h>
	#ifndef PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP
		// musl does not have that
		#define pthread_rwlockattr_setkind_np(a, b)
	#endif
#endif
#if defined(__MINGW32__) || defined(__MINGW64__) || (defined(_WIN32) && defined(__TINYC__))
	#undef PRId64
	#undef PRIi64
	#undef PRIo64
	#undef PRIu64
	#undef PRIx64
	#undef PRIX64
	#define PRId64 "lld"
	#define PRIi64 "lli"
	#define PRIo64 "llo"
	#define PRIu64 "llu"
	#define PRIx64 "llx"
	#define PRIX64 "llX"
#endif
#ifdef _VFREESTANDING
#undef _VFREESTANDING
#endif


// unsigned/signed comparisons
static inline bool _us32_gt(uint32_t a, int32_t b) { return a > INT32_MAX || (int32_t)a > b; }
static inline bool _us32_ge(uint32_t a, int32_t b) { return a >= INT32_MAX || (int32_t)a >= b; }
static inline bool _us32_eq(uint32_t a, int32_t b) { return a <= INT32_MAX && (int32_t)a == b; }
static inline bool _us32_ne(uint32_t a, int32_t b) { return a > INT32_MAX || (int32_t)a != b; }
static inline bool _us32_le(uint32_t a, int32_t b) { return a <= INT32_MAX && (int32_t)a <= b; }
static inline bool _us32_lt(uint32_t a, int32_t b) { return a < INT32_MAX && (int32_t)a < b; }
static inline bool _us64_gt(uint64_t a, int64_t b) { return a > INT64_MAX || (int64_t)a > b; }
static inline bool _us64_ge(uint64_t a, int64_t b) { return a >= INT64_MAX || (int64_t)a >= b; }
static inline bool _us64_eq(uint64_t a, int64_t b) { return a <= INT64_MAX && (int64_t)a == b; }
static inline bool _us64_ne(uint64_t a, int64_t b) { return a > INT64_MAX || (int64_t)a != b; }
static inline bool _us64_le(uint64_t a, int64_t b) { return a <= INT64_MAX && (int64_t)a <= b; }
static inline bool _us64_lt(uint64_t a, int64_t b) { return a < INT64_MAX && (int64_t)a < b; }


#if !defined(VNORETURN)
	#if defined(__TINYC__)
		#include <stdnoreturn.h>
		#define VNORETURN noreturn
	#endif
	# if !defined(__TINYC__) && defined(__STDC_VERSION__) && __STDC_VERSION__ >= 201112L
	#  define VNORETURN _Noreturn
	# elif !defined(VNORETURN) && defined(__GNUC__) && __GNUC__ >= 2
	#  define VNORETURN __attribute__((noreturn))
	# endif
	#ifndef VNORETURN
		#define VNORETURN
	#endif
#endif


#if !defined(VUNREACHABLE)
	#if defined(__GNUC__) && !defined(__clang__)
		#define V_GCC_VERSION  (__GNUC__ * 10000L + __GNUC_MINOR__ * 100L + __GNUC_PATCHLEVEL__)
		#if (V_GCC_VERSION >= 40500L) && !defined(__TINYC__)
			#define VUNREACHABLE()  do { __builtin_unreachable(); } while (0)
		#endif
	#endif
	#if defined(__clang__) && defined(__has_builtin) && !defined(__TINYC__)
		#if __has_builtin(__builtin_unreachable)
			#define VUNREACHABLE()  do { __builtin_unreachable(); } while (0)
		#endif
	#endif
	#ifndef VUNREACHABLE
		#define VUNREACHABLE() do { } while (0)
	#endif
#endif

#if __GLIBC__ == 2 && __GLIBC_MINOR__ < 30
#include <sys/syscall.h>
#define gettid() syscall(SYS_gettid)
#endif

// V includes:

#if defined(__TINYC__) && defined(__has_include)
// tcc does not support has_include properly yet, turn it off completely
#undef __has_include
#endif

#if !defined(_VFREESTANDING) && !defined(__vinix__)

// added by module `builtin.closure`, file: closure_nix.c.v:4:

#if defined(__has_include)

#if __has_include(<sys/mman.h>)
#include <sys/mman.h>
#else
#error VERROR_MESSAGE Header file <sys/mman.h>, needed for module `builtin.closure` was not found. Please install the corresponding development headers.
#endif

#else
#include <sys/mman.h>
#endif

#endif

#if !defined(_VNATIVE)

// added by module `builtin`, file: float.c.v:10:

#if defined(__has_include)

#if __has_include(<float.h>)
#include <float.h>
#else
#error VERROR_MESSAGE Header file <float.h>, needed for module `builtin` was not found. Please install the corresponding development headers.
#endif

#else
#include <float.h>
#endif

#endif

// added by module `main`, file: main.v:1:

#if defined(__has_include)

#if __has_include(<signal.h>)
#include <signal.h>
#else
#error VERROR_MESSAGE Header file <signal.h>, needed for module `main` was not found. Please install the corresponding development headers.
#endif

#else
#include <signal.h>
#endif


// V global/const #define ... :
#define _const_builtin__closure__assumed_page_size 16384
#define _const_degree 6
#define _const_max_len 11
#define _const_replace_stack_buffer_size 10
#define _const_kmp_stack_buffer_size 20

// Enum definitions:

typedef enum {
	builtin__closure__MemoryProtectAtrr__read_exec, // 
	builtin__closure__MemoryProtectAtrr__read_write, // +1
}  builtin__closure__MemoryProtectAtrr;

typedef enum {
	ArrayFlags__noslices = 1U, // u64(1) << 0
	ArrayFlags__noshrink = 2U, // u64(1) << 1
	ArrayFlags__nogrow = 4U, // u64(1) << 2
	ArrayFlags__nofree = 8U, // u64(1) << 3
}  ArrayFlags;

typedef enum {
	TrimMode__trim_left, // 
	TrimMode__trim_right, // +1
	TrimMode__trim_both, // +2
}  TrimMode;

// V type definitions:

struct string {
	u8* str;
	int len;
	int is_lit;
};

struct array {
	voidptr data;
	int offset;
	int len;
	int cap;
	ArrayFlags flags;
	int element_size;
};
typedef array Array_int;
typedef u8 Array_fixed_u8_15 [15];
typedef u8 Array_fixed_u8_6 [6];
typedef voidptr Array_fixed_voidptr_100 [100];
typedef u8 Array_fixed_u8_1000 [1000];
typedef int Array_fixed_int_10 [10];
typedef int Array_fixed_int_20 [20];
typedef voidptr (*anon_fn___voidptr)();
// #start sorted_symbols

struct builtin__closure__ClosureMutex {
	pthread_mutex_t closure_mtx;
};

struct builtin__closure__Closure {
	builtin__closure__ClosureMutex ClosureMutex;
	voidptr closure_ptr;
	anon_fn___voidptr closure_get_data;
	int closure_cap;
	int v_page_size;
};
// #end sorted_symbols

// BEGIN_multi_return_structs
// END_multi_return_structs


// V definitions:
// end of definitions #endif
VV_LOC void builtin__closure__closure_alloc(void);
VV_LOC void builtin__closure__closure_init(void);
VV_LOC voidptr builtin__closure__closure_create(voidptr func, voidptr data);
VV_LOC u8* builtin__closure__closure_alloc_platform(void);
VV_LOC void builtin__closure__closure_memory_protect_platform(voidptr ptr, isize size, builtin__closure__MemoryProtectAtrr attr);
VV_LOC int builtin__closure__get_page_size_platform(void);
VV_LOC void builtin__closure__closure_mtx_lock_init_platform(void);
VV_LOC void builtin__closure__closure_mtx_lock_platform(void);
VV_LOC void builtin__closure__closure_mtx_unlock_platform(void);
VV_LOC array builtin____new_array(int mylen, int cap, int elm_size);
VV_LOC array builtin____new_array_with_default(int mylen, int cap, int elm_size, voidptr val);
VV_LOC array builtin____new_array_with_multi_default(int mylen, int cap, int elm_size, voidptr val);
VV_LOC array builtin____new_array_with_array_default(int mylen, int cap, int elm_size, array val, int depth);
VV_LOC array builtin__new_array_from_c_array(int len, int cap, int elm_size, voidptr c_array);
VV_LOC voidptr builtin__array_get_unsafe(array a, int i);
VV_LOC voidptr builtin__array_get(array a, int i);
VV_LOC array builtin__array_slice(array a, int start, int _end);
VV_LOC array builtin__array_clone_static_to_depth(array a, int depth);
array builtin__array_clone_to_depth(array* a, int depth);
VV_LOC void builtin__array_set_unsafe(array* a, int i, voidptr val);
VV_LOC void builtin__array_set(array* a, int i, voidptr val);
void builtin__array_sort(array* a, int (*callback)(voidptr , voidptr ));
VV_LOC void builtin__panic_on_negative_len(int len);
VV_LOC void builtin__panic_on_negative_cap(int cap);
VV_LOC array builtin____new_array_with_default_noscan(int mylen, int cap, int elm_size, voidptr val);
void builtin__print_backtrace(void);
VV_LOC void builtin__eprint_space_padding(string output, int max_len);
bool builtin__print_backtrace_skipping_top_frames(int xskipframes);
VV_LOC bool builtin__print_backtrace_skipping_top_frames_linux(int skipframes);
VV_LOC void builtin__v_segmentation_fault_handler(i32 signal_number);
void builtin___v_exit(int code);
string builtin__vcurrent_hash(void);
void builtin___v_panic(string s);
void builtin__panic_n(string s, i64 number1);
void builtin__panic_n2(string s, i64 number1, i64 number2);
void builtin__eprintln(string s);
void builtin__eprint(string s);
void builtin__flush_stdout(void);
void builtin__flush_stderr(void);
void builtin__println(string s);
VV_LOC void builtin___writeln_to_fd(int fd, string s);
VV_LOC void builtin___write_buf_to_fd(int fd, u8* buf, int buf_len);
VV_LOC void builtin___memory_panic(string fname, isize size);
u8* builtin___v_malloc(isize n);
u8* builtin__malloc_noscan(isize n);
VV_LOC u64 builtin____at_least_one(u64 how_many);
u8* builtin__malloc_uncollectable(isize n);
u8* builtin__vcalloc(isize n);
void builtin___v_free(voidptr ptr);
voidptr builtin__memdup(voidptr src, isize sz);
voidptr builtin__memdup_uncollectable(voidptr src, isize sz);
VV_LOC int builtin__v_fixed_index(int i, int len);
bool builtin__isnil(voidptr v);
VV_LOC void builtin__builtin_init(void);
int builtin__vstrlen(u8* s);
voidptr builtin__vmemcpy(voidptr dest, const voidptr const_src, isize n);
voidptr builtin__vmemmove(voidptr dest, const voidptr const_src, isize n);
int builtin__vmemcmp(const voidptr const_s1, const voidptr const_s2, isize n);
string builtin__i64_str(i64 nn);
VV_LOC string builtin__impl_i64_to_string(i64 nn);
VV_LOC bool builtin__fast_string_eq(string a, string b);
string builtin__tos(u8* s, int len);
string builtin__tos2(u8* s);
string builtin__string_clone(string a);
string builtin__string_replace(string s, string rep, string with);
VV_LOC bool builtin__string__eq(string s, string a);
VV_LOC bool builtin__string__lt(string s, string a);
VV_LOC string builtin__string__plus(string s, string a);
string builtin__string_substr(string s, int start, int _end);
VV_LOC int builtin__string_index_(string s, string p);
VV_LOC int builtin__string_index_kmp(string s, string p);
int builtin__string_index_after_(string s, string p, int start);
bool builtin__string_contains_u8(string s, u8 x);
bool builtin__string_contains(string s, string substr);
VV_LOC string builtin__string_trim_chars(string s, string cutset, TrimMode mode);
string builtin__string_str(string s);
VV_LOC u8 builtin__string_at(string s, int idx);
string builtin__string_all_before(string s, string sub);
string builtin__string_all_after(string s, string sub);
void main__print_hello_world(void);
VV_EXP void print_hello_world(void); // exported fn main.print_hello_world
int main__sum(int a, int b);
VV_EXP int sum(int a, int b); // exported fn main.sum
void main__sort_array(Array_int* arr);
VV_LOC bool anon_fn_aa4c3c73e99943ac_int_int__bool_274(int* a, int* b);
VV_EXP void sort_array(Array_int* arr); // exported fn main.sort_array
VV_LOC void main__main(void);

// V global/const non-precomputed definitions:
string _const_digit_pairs; // a string literal, inited later
builtin__closure__Closure g_closure; // global 6

Array_fixed_u8_15 _const_builtin__closure__closure_thunk; // inited later
Array_fixed_u8_6 _const_builtin__closure__closure_get_data_bytes; // inited later
const u64 _const_math__bits__two32 = 4294967296U; // precomputed2
bool v_memory_panic = false; // global 6

int g_main_argc = ((int)(0)); // global 6

voidptr g_main_argv = ((void*)0); // global 6

voidptr g_live_reload_info; // global 6

const i32 _const_max_i32 = 2147483647; // precomputed2
i64 _const_min_i64; // inited later
i64 _const_max_i64; // inited later
u32 _const_builtin__closure__closure_size_1; // inited later
int _const_builtin__closure__closure_size; // inited later

// V sort fn definitions:
VV_LOC  int anon_fn_aa4c3c73e99943ac_int_int__bool_274_lambda_wrapper(int* a, int* b) {
	if (anon_fn_aa4c3c73e99943ac_int_int__bool_274(a, b)) return -1;
	else return 1;
}


// end of V out (header)

// V anon functions:
	VV_LOC bool anon_fn_aa4c3c73e99943ac_int_int__bool_274(int* a, int* b) {
	return *a < *b;
}


// >> typeof() support for sum types / interfaces
// << typeof() support for sum types

VV_LOC void builtin__closure__closure_alloc(void) {
	u8* p = builtin__closure__closure_alloc_platform();
	if (builtin__isnil(p)) {
		return;
	}
	u8* x = p + g_closure.v_page_size;
	int remaining = (int)(g_closure.v_page_size / _const_builtin__closure__closure_size);
	g_closure.closure_ptr = x;
	g_closure.closure_cap = remaining;
	for (;;) {
		if (!(remaining > 0)) break;
		builtin__vmemcpy(x, &_const_builtin__closure__closure_thunk[0], 15);
		remaining--;
		{ // Unsafe block
			x += _const_builtin__closure__closure_size;
		}
	}
	builtin__closure__closure_memory_protect_platform(g_closure.closure_ptr, g_closure.v_page_size, builtin__closure__MemoryProtectAtrr__read_exec);
}
VV_LOC void builtin__closure__closure_init(void) {
	int page_size = builtin__closure__get_page_size_platform();
	g_closure.v_page_size = page_size;
	builtin__closure__closure_mtx_lock_init_platform();
	builtin__closure__closure_alloc();
	{ // Unsafe block
		builtin__closure__closure_memory_protect_platform(g_closure.closure_ptr, page_size, builtin__closure__MemoryProtectAtrr__read_write);
		builtin__vmemcpy(g_closure.closure_ptr, &_const_builtin__closure__closure_get_data_bytes[0], 6);
		builtin__closure__closure_memory_protect_platform(g_closure.closure_ptr, page_size, builtin__closure__MemoryProtectAtrr__read_exec);
	}
	g_closure.closure_get_data = (voidptr)g_closure.closure_ptr;
	{ // Unsafe block
		g_closure.closure_ptr = ((u8*)(g_closure.closure_ptr)) + _const_builtin__closure__closure_size;
	}
	g_closure.closure_cap--;
}
VV_LOC voidptr builtin__closure__closure_create(voidptr func, voidptr data) {
	builtin__closure__closure_mtx_lock_platform();
	if (g_closure.closure_cap == 0) {
		builtin__closure__closure_alloc();
	}
	g_closure.closure_cap--;
	voidptr curr_closure = g_closure.closure_ptr;
	{ // Unsafe block
		g_closure.closure_ptr = ((u8*)(g_closure.closure_ptr)) + _const_builtin__closure__closure_size;
		voidptr* p = ((voidptr*)(((u8*)(curr_closure)) - _const_builtin__closure__assumed_page_size));
		p[0] = data;
		p[1] = func;
	}
	builtin__closure__closure_mtx_unlock_platform();
	return curr_closure;
}
#if !defined(_VFREESTANDING) && !defined(__vinix__)
#endif
inline VV_LOC u8* builtin__closure__closure_alloc_platform(void) {
	u8* p = ((u8*)(((void*)0)));
	#if defined(_VFREESTANDING)
	{
	}
	#else
	{
		p = mmap(0, (int)(g_closure.v_page_size * 2), (PROT_READ | PROT_WRITE), (MAP_ANONYMOUS | MAP_PRIVATE), -1, 0);
		if (p == ((u8*)(MAP_FAILED))) {
			return ((void*)0);
		}
	}
	#endif
	return p;
}
inline VV_LOC void builtin__closure__closure_memory_protect_platform(voidptr ptr, isize size, builtin__closure__MemoryProtectAtrr attr) {
	#if defined(_VFREESTANDING)
	{
	}
	#else
	{

		if (attr == (builtin__closure__MemoryProtectAtrr__read_exec)) {
			mprotect(ptr, size, (PROT_READ | PROT_EXEC));
		}
		else if (attr == (builtin__closure__MemoryProtectAtrr__read_write)) {
			mprotect(ptr, size, (PROT_READ | PROT_WRITE));
		}
	}
	#endif
}
inline VV_LOC int builtin__closure__get_page_size_platform(void) {
	int page_size = 0x4000;
	#if !defined(_VFREESTANDING)
	{
		page_size = ((int)(sysconf(_SC_PAGESIZE)));
	}
	#endif
	page_size = (int)(page_size * ((int)(((int)(((int)(_const_builtin__closure__assumed_page_size - 1)) / page_size)) + 1)));
	return page_size;
}
inline VV_LOC void builtin__closure__closure_mtx_lock_init_platform(void) {
	#if !defined(_VFREESTANDING) || defined(__vinix__)
	{
		pthread_mutex_init(&g_closure.ClosureMutex.closure_mtx, 0);
	}
	#endif
}
inline VV_LOC void builtin__closure__closure_mtx_lock_platform(void) {
	#if !defined(_VFREESTANDING) || defined(__vinix__)
	{
		pthread_mutex_lock(&g_closure.ClosureMutex.closure_mtx);
	}
	#endif
}
inline VV_LOC void builtin__closure__closure_mtx_unlock_platform(void) {
	#if !defined(_VFREESTANDING) || defined(__vinix__)
	{
		pthread_mutex_unlock(&g_closure.ClosureMutex.closure_mtx);
	}
	#endif
}
VV_LOC array builtin____new_array(int mylen, int cap, int elm_size) {
	builtin__panic_on_negative_len(mylen);
	builtin__panic_on_negative_cap(cap);
	int cap_ = (cap < mylen ? (mylen) : (cap));
	array arr = ((array){.data = (voidptr)builtin__vcalloc((u64)(((u64)(cap_)) * ((u64)(elm_size)))),.offset = 0,.len = mylen,.cap = cap_,.flags = 0,.element_size = elm_size,});
	return arr;
}
VV_LOC array builtin____new_array_with_default(int mylen, int cap, int elm_size, voidptr val) {
	builtin__panic_on_negative_len(mylen);
	builtin__panic_on_negative_cap(cap);
	int cap_ = (cap < mylen ? (mylen) : (cap));
	array arr = ((array){.data = 0,.offset = 0,.len = mylen,.cap = cap_,.flags = 0,.element_size = elm_size,});
	u64 total_size = (u64)(((u64)(cap_)) * ((u64)(elm_size)));
	if (cap_ > 0 && mylen == 0) {
		arr.data = builtin___v_malloc(builtin____at_least_one(total_size));
	} else {
		arr.data = builtin__vcalloc(total_size);
	}
	if (val != 0) {
		u8* eptr = ((u8*)(arr.data));
		{ // Unsafe block
			if (eptr != ((void*)0)) {
				if (arr.element_size == 1) {
					u8 byte_value = *(((u8*)(val)));
					for (int i = 0; i < arr.len; ++i) {
						eptr[i] = byte_value;
					}
				} else {
					for (int _t1 = 0; _t1 < arr.len; ++_t1) {
						builtin__vmemcpy(eptr, val, arr.element_size);
						eptr += arr.element_size;
					}
				}
			}
		}
	}
	return arr;
}
VV_LOC array builtin____new_array_with_multi_default(int mylen, int cap, int elm_size, voidptr val) {
	builtin__panic_on_negative_len(mylen);
	builtin__panic_on_negative_cap(cap);
	int cap_ = (cap < mylen ? (mylen) : (cap));
	array arr = ((array){.data = 0,.offset = 0,.len = mylen,.cap = cap_,.flags = 0,.element_size = elm_size,});
	u64 total_size = (u64)(((u64)(cap_)) * ((u64)(elm_size)));
	arr.data = builtin__vcalloc(builtin____at_least_one(total_size));
	if (val != 0) {
		u8* eptr = ((u8*)(arr.data));
		{ // Unsafe block
			if (eptr != ((void*)0)) {
				for (int i = 0; i < arr.len; ++i) {
					builtin__vmemcpy(eptr, ((charptr)(val)) + (int)(i * arr.element_size), arr.element_size);
					eptr += arr.element_size;
				}
			}
		}
	}
	return arr;
}
VV_LOC array builtin____new_array_with_array_default(int mylen, int cap, int elm_size, array val, int depth) {
	builtin__panic_on_negative_len(mylen);
	builtin__panic_on_negative_cap(cap);
	int cap_ = (cap < mylen ? (mylen) : (cap));
	array arr = ((array){.data = (voidptr)builtin___v_malloc(builtin____at_least_one((u64)(((u64)(cap_)) * ((u64)(elm_size))))),.offset = 0,.len = mylen,.cap = cap_,.flags = 0,.element_size = elm_size,});
	u8* eptr = ((u8*)(arr.data));
	{ // Unsafe block
		if (eptr != ((void*)0)) {
			for (int _t1 = 0; _t1 < arr.len; ++_t1) {
				array val_clone = builtin__array_clone_to_depth(&val, depth);
				builtin__vmemcpy(eptr, &val_clone, arr.element_size);
				eptr += arr.element_size;
			}
		}
	}
	return arr;
}
VV_LOC array builtin__new_array_from_c_array(int len, int cap, int elm_size, voidptr c_array) {
	builtin__panic_on_negative_len(len);
	builtin__panic_on_negative_cap(cap);
	int cap_ = (cap < len ? (len) : (cap));
	array arr = ((array){.data = (voidptr)builtin__vcalloc((u64)(((u64)(cap_)) * ((u64)(elm_size)))),.offset = 0,.len = len,.cap = cap_,.flags = 0,.element_size = elm_size,});
	builtin__vmemcpy(arr.data, c_array, (u64)(((u64)(len)) * ((u64)(elm_size))));
	return arr;
}
inline VV_LOC voidptr builtin__array_get_unsafe(array a, int i) {
	{ // Unsafe block
		return ((u8*)(a.data)) + (u64)(((u64)(i)) * ((u64)(a.element_size)));
	}
	return 0;
}
VV_LOC voidptr builtin__array_get(array a, int i) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (i < 0 || i >= a.len) {
			builtin__panic_n2(_S("array.get: index out of range (i,a.len):"), i, a.len);
			VUNREACHABLE();
		}
	}
	#endif
	{ // Unsafe block
		return ((u8*)(a.data)) + (u64)(((u64)(i)) * ((u64)(a.element_size)));
	}
	return 0;
}
VV_LOC array builtin__array_slice(array a, int start, int _end) {
	int end = (_end == _const_max_i64 || _end == _const_max_i32 ? (a.len) : (_end));
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (start > end) {
			builtin___v_panic(builtin__string__plus(builtin__string__plus(builtin__string__plus(_S("array.slice: invalid slice index (start>end):"), builtin__impl_i64_to_string(((i64)(start)))), _S(", ")), builtin__impl_i64_to_string(end)));
			VUNREACHABLE();
		}
		if (end > a.len) {
			builtin___v_panic(builtin__string__plus(builtin__string__plus(builtin__string__plus(builtin__string__plus(_S("array.slice: slice bounds out of range ("), builtin__impl_i64_to_string(end)), _S(" >= ")), builtin__impl_i64_to_string(a.len)), _S(")")));
			VUNREACHABLE();
		}
		if (start < 0) {
			builtin___v_panic(builtin__string__plus(_S("array.slice: slice bounds out of range (start<0):"), builtin__impl_i64_to_string(start)));
			VUNREACHABLE();
		}
	}
	#endif
	u64 offset = (u64)(((u64)(start)) * ((u64)(a.element_size)));
	u8* data = ((u8*)(a.data)) + offset;
	int l = (int)(end - start);
	array res = ((array){.data = (voidptr)data,.offset = (int)(a.offset + ((int)(offset))),.len = l,.cap = l,.flags = 0,.element_size = a.element_size,});
	return res;
}
VV_LOC array builtin__array_clone_static_to_depth(array a, int depth) {
	return builtin__array_clone_to_depth(&a, depth);
}
array builtin__array_clone_to_depth(array* a, int depth) {
	u64 source_capacity_in_bytes = (u64)(((u64)(a->cap)) * ((u64)(a->element_size)));
	array arr = ((array){.data = (voidptr)builtin__vcalloc(source_capacity_in_bytes),.offset = 0,.len = a->len,.cap = a->cap,.flags = 0,.element_size = a->element_size,});
	if (depth > 0 && _us32_eq(sizeof(array),a->element_size) && a->len >= 0 && a->cap >= a->len) {
		array ar = ((array){.data = 0,.offset = 0,.len = 0,.cap = 0,.flags = 0,.element_size = 0,});
		int asize = ((int)(sizeof(array)));
		for (int i = 0; i < a->len; ++i) {
			builtin__vmemcpy(&ar, builtin__array_get_unsafe(*a, i), asize);
			array ar_clone = builtin__array_clone_to_depth(&ar, (int)(depth - 1));
			builtin__array_set_unsafe(&arr, i, &ar_clone);
		}
		return arr;
	} else {
		if (a->data != 0 && source_capacity_in_bytes > 0) {
			builtin__vmemcpy(((u8*)(arr.data)), a->data, source_capacity_in_bytes);
		}
		return arr;
	}
	return (array){.data = 0,.offset = 0,.len = 0,.cap = 0,.flags = 0,.element_size = 0,};
}
inline VV_LOC void builtin__array_set_unsafe(array* a, int i, voidptr val) {
	builtin__vmemcpy(((u8*)(a->data)) + (u64)(((u64)(a->element_size)) * ((u64)(i))), val, a->element_size);
}
VV_LOC void builtin__array_set(array* a, int i, voidptr val) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (i < 0 || i >= a->len) {
			builtin__panic_n2(_S("array.set: index out of range (i,a.len):"), i, a->len);
			VUNREACHABLE();
		}
	}
	#endif
	builtin__vmemcpy(((u8*)(a->data)) + (u64)(((u64)(a->element_size)) * ((u64)(i))), val, a->element_size);
}
void builtin__array_sort(array* a, int (*callback)(voidptr , voidptr ));
inline VV_LOC void builtin__panic_on_negative_len(int len) {
	if (len < 0) {
		builtin__panic_n(_S("negative .len:"), len);
		VUNREACHABLE();
	}
}
inline VV_LOC void builtin__panic_on_negative_cap(int cap) {
	if (cap < 0) {
		builtin__panic_n(_S("negative .cap:"), cap);
		VUNREACHABLE();
	}
}
VV_LOC array builtin____new_array_with_default_noscan(int mylen, int cap, int elm_size, voidptr val) {
	return builtin____new_array_with_default(mylen, cap, elm_size, val);
}
void builtin__print_backtrace(void) {
	#if !defined(CUSTOM_DEFINE_no_backtrace)
	{
		#if defined(_VFREESTANDING)
		{
		}
		#elif defined(_VNATIVE)
		{
		}
		#elif defined(__TINYC__)
		{
		}
		#elif defined(CUSTOM_DEFINE_use_libbacktrace)
		{
		}
		#else
		{
			builtin__print_backtrace_skipping_top_frames(2);
		}
		#endif
	}
	#endif
}
VV_LOC void builtin__eprint_space_padding(string output, int max_len) {
	int padding_len = (int)(max_len - output.len);
	if (padding_len > 0) {
		for (int _t1 = 0; _t1 < padding_len; ++_t1) {
			builtin__eprint(_S(" "));
		}
	}
}
bool builtin__print_backtrace_skipping_top_frames(int xskipframes) {
	#if defined(CUSTOM_DEFINE_no_backtrace)
	{
	}
	#else
	{
		int skipframes = (int)(xskipframes + 2);
		#if defined(__APPLE__) || defined(__FreeBSD__) || defined(__OpenBSD__) || defined(__NetBSD__)
		{
		}
		#elif defined(__linux__)
		{
			return builtin__print_backtrace_skipping_top_frames_linux(skipframes);
		}
		#else
		{
		}
		#endif
	}
	#endif
	return false;
}
VV_LOC bool builtin__print_backtrace_skipping_top_frames_linux(int skipframes) {
	#if defined(_VNATIVE)
	{
	}
	#elif defined(CUSTOM_DEFINE_no_backtrace)
	{
	}
	#else
	{
		#if defined(__linux__) && !defined(_VFREESTANDING)
		{
			#if defined(__TINYC__)
			{
			}
			#else
			{
				Array_fixed_voidptr_100 buffer = {0};
				int nr_ptrs = backtrace(&buffer[0], 100);
				if (nr_ptrs < 2) {
					builtin__eprintln(_S("C.backtrace returned less than 2 frames"));
					return false;
				}
				int nr_actual_frames = (int)(nr_ptrs - skipframes);
				char** csymbols = backtrace_symbols(((voidptr)(&buffer[skipframes])), nr_actual_frames);
				for (int i = 0; i < nr_actual_frames; ++i) {
					string sframe = builtin__tos2(((u8*)(csymbols[i])));
					string executable = builtin__string_all_before(sframe, _S("("));
					string addr = builtin__string_all_before(builtin__string_all_after(sframe, _S("[")), _S("]"));
					string beforeaddr = builtin__string_all_before(sframe, _S("["));
					string cmd = builtin__string__plus(builtin__string__plus(builtin__string__plus(_S("addr2line -e "), executable), _S(" ")), addr);
					voidptr f = popen(((char*)(cmd.str)), "r");
					if (f == ((void*)0)) {
						builtin__eprintln(sframe);
						continue;
					}
					Array_fixed_u8_1000 buf = {0};
					string output = _S("");
					{ // Unsafe block
						u8* bp = &buf[0];
						for (;;) {
							if (!(fgets(((char*)(bp)), 1000, f) != 0)) break;
							output = builtin__string__plus(output, builtin__tos(bp, builtin__vstrlen(bp)));
						}
					}
					output = builtin__string__plus(builtin__string_trim_chars(output, _S(" \t\n"), TrimMode__trim_both), _S(":"));
					if (pclose(f) != 0) {
						builtin__eprintln(sframe);
						continue;
					}
					if (_SLIT_EQ(output.str, output.len, "??:0:") || _SLIT_EQ(output.str, output.len, "??:?:")) {
						output = _S("");
					}
					output = builtin__string_replace(output, _S(" (discriminator"), _S(": (d."));
					builtin__eprint(output);
					builtin__eprint_space_padding(output, 55);
					builtin__eprint(_S(" | "));
					builtin__eprint(addr);
					builtin__eprint(_S(" | "));
					builtin__eprintln(beforeaddr);
				}
				if (nr_actual_frames > 0) {
					free(csymbols);
				}
			}
			#endif
		}
		#endif
	}
	#endif
	return true;
}
VV_LOC void builtin__v_segmentation_fault_handler(i32 signal_number) {
	#if defined(_VFREESTANDING)
	{
	}
	#else
	{
		fprintf(stderr, "signal %d: segmentation fault\n", signal_number);
	}
	#endif
	#if defined(CUSTOM_DEFINE_use_libbacktrace)
	{
	}
	#else
	{
		builtin__print_backtrace();
	}
	#endif
	builtin___v_exit((i32)(128 + signal_number));
	VUNREACHABLE();
}
VNORETURN void builtin___v_exit(int code) {
	exit(code);
	VUNREACHABLE();
	while(1);
}
string builtin__vcurrent_hash(void) {
	return _S("d3ed361");
}
VNORETURN void builtin___v_panic(string s) {
	#if defined(_VFREESTANDING)
	{
	}
	#else
	{
		builtin__eprint(_S("V panic: "));
		builtin__eprintln(s);
		builtin__eprint(_S("v hash: "));
		builtin__eprintln(builtin__vcurrent_hash());
		builtin__flush_stdout();
		#if defined(_VNATIVE)
		{
		}
		#elif defined(CUSTOM_DEFINE_exit_after_panic_message)
		{
		}
		#elif defined(CUSTOM_DEFINE_no_backtrace)
		{
		}
		#else
		{
			#if defined(CUSTOM_DEFINE_use_libbacktrace)
			{
			}
			#else
			{
				builtin__print_backtrace_skipping_top_frames(1);
			}
			#endif
			exit(1);
			VUNREACHABLE();
		}
		#endif
	}
	#endif
	exit(1);
	VUNREACHABLE();
	while(1);
}
VNORETURN void builtin__panic_n(string s, i64 number1) {
	builtin___v_panic(builtin__string__plus(s, builtin__impl_i64_to_string(number1)));
	VUNREACHABLE();
	while(1);
}
VNORETURN void builtin__panic_n2(string s, i64 number1, i64 number2) {
	builtin___v_panic(builtin__string__plus(builtin__string__plus(builtin__string__plus(s, builtin__impl_i64_to_string(number1)), _S(", ")), builtin__impl_i64_to_string(number2)));
	VUNREACHABLE();
	while(1);
}
void builtin__eprintln(string s) {
	if (s.str == 0) {
		builtin__eprintln(_S("eprintln(NIL)"));
		return;
	}
	#if defined(_VFREESTANDING)
	{
	}
	#elif defined(__TARGET_IOS__)
	{
	}
	#else
	{
		builtin__flush_stdout();
		builtin__flush_stderr();
		builtin___writeln_to_fd(2, s);
		builtin__flush_stderr();
	}
	#endif
}
void builtin__eprint(string s) {
	if (s.str == 0) {
		builtin__eprint(_S("eprint(NIL)"));
		return;
	}
	#if defined(_VFREESTANDING)
	{
	}
	#elif defined(__TARGET_IOS__)
	{
	}
	#else
	{
		builtin__flush_stdout();
		builtin__flush_stderr();
		builtin___write_buf_to_fd(2, s.str, s.len);
		builtin__flush_stderr();
	}
	#endif
}
void builtin__flush_stdout(void) {
	#if defined(_VFREESTANDING)
	{
	}
	#else
	{
		fflush(stdout);
	}
	#endif
}
void builtin__flush_stderr(void) {
	#if defined(_VFREESTANDING)
	{
	}
	#else
	{
		fflush(stderr);
	}
	#endif
}
void builtin__println(string s) {
	if (s.str == 0) {
		builtin__println(_S("println(NIL)"));
		return;
	}
	#if defined(__ANDROID__) && !defined(__TERMUX__)
	{
	}
	#elif defined(__TARGET_IOS__)
	{
	}
	#elif defined(_VFREESTANDING)
	{
	}
	#else
	{
		builtin___writeln_to_fd(1, s);
	}
	#endif
}
VV_LOC void builtin___writeln_to_fd(int fd, string s) {
	#if defined(CUSTOM_DEFINE_builtin_writeln_should_write_at_once)
	{
	}
	#else
	{
		u8 lf = ((u8)('\n'));
		builtin___write_buf_to_fd(fd, s.str, s.len);
		builtin___write_buf_to_fd(fd, &lf, 1);
	}
	#endif
}
VV_LOC void builtin___write_buf_to_fd(int fd, u8* buf, int buf_len) {
	if (buf_len <= 0) {
		return;
	}
	u8* ptr = buf;
	isize remaining_bytes = ((isize)(buf_len));
	isize x = ((isize)(0));
	#if defined(_VFREESTANDING) || defined(__vinix__) || defined(CUSTOM_DEFINE_builtin_write_buf_to_fd_should_use_c_write)
	{
	}
	#else
	{
		voidptr stream = ((voidptr)(stdout));
		if (fd == 2) {
			stream = ((voidptr)(stderr));
		}
		{ // Unsafe block
			for (;;) {
				if (!(remaining_bytes > 0)) break;
				x = ((isize)(fwrite(ptr, 1, remaining_bytes, stream)));
				ptr += x;
				remaining_bytes -= x;
			}
		}
	}
	#endif
}
VNORETURN VV_LOC void builtin___memory_panic(string fname, isize size) {
	v_memory_panic = true;
	builtin__eprint(fname);
	builtin__eprint(_S("("));
	#if defined(_VFREESTANDING) || defined(__vinix__)
	{
	}
	#else
	{
		fprintf(stderr, "%p", ((voidptr)(size)));
	}
	#endif
	if (size < 0) {
		builtin__eprint(_S(" < 0"));
	}
	builtin__eprintln(_S(")"));
	builtin___v_panic(_S("memory allocation failure"));
	VUNREACHABLE();
	while(1);
}
u8* builtin___v_malloc(isize n) {
	if (n < 0) {
		builtin___memory_panic(_S("malloc"), n);
		VUNREACHABLE();
	} else if (n == 0) {
		return ((u8*)(((void*)0)));
	}
	u8* res = ((u8*)(((void*)0)));
	#if defined(_VPREALLOC)
	{
	}
	#elif defined(CUSTOM_DEFINE_gcboehm)
	{
	}
	#elif defined(_VFREESTANDING)
	{
	}
	#else
	{
		#if defined(_WIN32)
		{
		}
		#else
		{
			res = malloc(n);
		}
		#endif
	}
	#endif
	if (res == 0) {
		builtin___memory_panic(_S("malloc"), n);
		VUNREACHABLE();
	}
	return res;
}
u8* builtin__malloc_noscan(isize n) {
	if (n < 0) {
		builtin___memory_panic(_S("malloc_noscan"), n);
		VUNREACHABLE();
	}
	u8* res = ((u8*)(((void*)0)));
	#if defined(_VNATIVE)
	{
	}
	#elif defined(_VPREALLOC)
	{
	}
	#elif defined(CUSTOM_DEFINE_gcboehm)
	{
	}
	#elif defined(_VFREESTANDING)
	{
	}
	#else
	{
		#if defined(_WIN32)
		{
		}
		#else
		{
			res = malloc(n);
		}
		#endif
	}
	#endif
	if (res == 0) {
		builtin___memory_panic(_S("malloc_noscan"), n);
		VUNREACHABLE();
	}
	return res;
}
inline VV_LOC u64 builtin____at_least_one(u64 how_many) {
	if (how_many == 0) {
		return 1;
	}
	return how_many;
}
u8* builtin__malloc_uncollectable(isize n) {
	if (n < 0) {
		builtin___memory_panic(_S("malloc_uncollectable"), n);
		VUNREACHABLE();
	}
	u8* res = ((u8*)(((void*)0)));
	#if defined(_VPREALLOC)
	{
	}
	#elif defined(CUSTOM_DEFINE_gcboehm)
	{
	}
	#elif defined(_VFREESTANDING)
	{
	}
	#else
	{
		#if defined(_WIN32)
		{
		}
		#else
		{
			res = malloc(n);
		}
		#endif
	}
	#endif
	if (res == 0) {
		builtin___memory_panic(_S("malloc_uncollectable"), n);
		VUNREACHABLE();
	}
	return res;
}
u8* builtin__vcalloc(isize n) {
	if (n < 0) {
		builtin___memory_panic(_S("vcalloc"), n);
		VUNREACHABLE();
	} else if (n == 0) {
		return ((u8*)(((void*)0)));
	}
	#if defined(_VPREALLOC)
	{
	}
	#elif defined(_VNATIVE)
	{
	}
	#elif defined(CUSTOM_DEFINE_gcboehm)
	{
	}
	#else
	{
		#if defined(_WIN32)
		{
		}
		#else
		{
			return calloc(1, n);
		}
		#endif
	}
	#endif
	return ((u8*)(((void*)0)));
}
void builtin___v_free(voidptr ptr) {
	if (ptr == 0) {
		return;
	}
	#if defined(_VPREALLOC)
	{
	}
	#elif defined(CUSTOM_DEFINE_gcboehm)
	{
	}
	#else
	{
		#if defined(_WIN32)
		{
		}
		#else
		{
			free(ptr);
		}
		#endif
	}
	#endif
}
voidptr builtin__memdup(voidptr src, isize sz) {
	if (sz == 0) {
		return builtin__vcalloc(1);
	}
	{ // Unsafe block
		u8* mem = builtin___v_malloc(sz);
		return memcpy(mem, src, sz);
	}
	return 0;
}
voidptr builtin__memdup_uncollectable(voidptr src, isize sz) {
	if (sz == 0) {
		return builtin__vcalloc(1);
	}
	{ // Unsafe block
		u8* mem = builtin__malloc_uncollectable(sz);
		return memcpy(mem, src, sz);
	}
	return 0;
}
inline VV_LOC int builtin__v_fixed_index(int i, int len) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (i < 0 || i >= len) {
			builtin___v_panic(builtin__string__plus(builtin__string__plus(builtin__string__plus(builtin__string__plus(_S("fixed array index out of range (index: "), builtin__i64_str(((i64)(i)))), _S(", len: ")), builtin__i64_str(((i64)(len)))), _S(")")));
			VUNREACHABLE();
		}
	}
	#endif
	return i;
}
inline bool builtin__isnil(voidptr v) {
	return v == 0;
}
VV_LOC void builtin__builtin_init(void) {
}
inline int builtin__vstrlen(u8* s) {
	return strlen(((char*)(s)));
}
inline voidptr builtin__vmemcpy(voidptr dest, const voidptr const_src, isize n) {
	if (n == 0) {
		return dest;
	}
	{ // Unsafe block
		return memcpy(dest, const_src, n);
	}
	return 0;
}
inline voidptr builtin__vmemmove(voidptr dest, const voidptr const_src, isize n) {
	if (n == 0) {
		return dest;
	}
	{ // Unsafe block
		return memmove(dest, const_src, n);
	}
	return 0;
}
inline int builtin__vmemcmp(const voidptr const_s1, const voidptr const_s2, isize n) {
	if (n == 0) {
		return 0;
	}
	{ // Unsafe block
		return memcmp(const_s1, const_s2, n);
	}
	return 0;
}
#if !defined(CUSTOM_DEFINE_nofloat)
#endif
#if !defined(_VNATIVE)
#endif
inline string builtin__i64_str(i64 nn) {
	return builtin__impl_i64_to_string(nn);
}
VV_LOC string builtin__impl_i64_to_string(i64 nn) {
	{ // Unsafe block
		i64 n = nn;
		i64 d = ((i64)(0));
		if (n == 0) {
			return _S("0");
		} else if (n == _const_min_i64) {
			return _S("-9223372036854775808");
		}
		int max = 20;
		u8* buf = builtin__malloc_noscan((int)(max + 1));
		bool is_neg = false;
		if (n < 0) {
			n = -n;
			is_neg = true;
		}
		int index = max;
		buf[index] = 0;
		index--;
		for (;;) {
			if (!(n > 0)) break;
			i64 n1 = (i64)(n / ((i64)(100)));
			d = ((((u32)((i64)(n - ((i64)(n1 * ((i64)(100))))))) << ((i64)(1))));
			n = n1;
			buf[index] = _const_digit_pairs.str[ d];
			index--;
			d++;
			buf[index] = _const_digit_pairs.str[ d];
			index--;
		}
		index++;
		if (d < ((i64)(20))) {
			index++;
		}
		if (is_neg) {
			index--;
			buf[index] = '-';
		}
		int diff = (int)(max - index);
		builtin__vmemmove(buf, ((voidptr)(buf + index)), (int)(diff + 1));
		return builtin__tos(buf, diff);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
inline VV_LOC bool builtin__fast_string_eq(string a, string b) {
	if (a.len != b.len) {
		return false;
	}
	{ // Unsafe block
		return memcmp(a.str, b.str, b.len) == 0;
	}
	return 0;
}
string builtin__tos(u8* s, int len) {
	if (s == 0) {
		builtin___v_panic(_S("tos(): nil string"));
		VUNREACHABLE();
	}
	return ((string){.str = s, .len = len});
}
string builtin__tos2(u8* s) {
	if (s == 0) {
		builtin___v_panic(_S("tos2: nil string"));
		VUNREACHABLE();
	}
	return ((string){.str = s, .len = builtin__vstrlen(s)});
}
string builtin__string_clone(string a) {
	if (a.len <= 0) {
		return _S("");
	}
	string b = ((string){.str = builtin__malloc_noscan((int)(a.len + 1)), .len = a.len});
	{ // Unsafe block
		builtin__vmemcpy(b.str, a.str, a.len);
		b.str[a.len] = 0;
	}
	return b;
}
string builtin__string_replace(string s, string rep, string with) {
	if (s.len == 0 || rep.len == 0 || rep.len > s.len) {
		return builtin__string_clone(s);
	}
	if (!builtin__string_contains(s, rep)) {
		return builtin__string_clone(s);
	}
	int pidxs_len = 0;
	int pidxs_cap = (int)(s.len / rep.len);
	Array_fixed_int_10 stack_idxs = {0};
	int* pidxs = &stack_idxs[0];
	if (pidxs_cap > _const_replace_stack_buffer_size) {
		pidxs = ((int*)(builtin___v_malloc((int)(((int)(sizeof(int))) * pidxs_cap))));
	}
	int idx = 0;
	for (;;) {
		idx = builtin__string_index_after_(s, rep, idx);
		if (idx == -1) {
			break;
		}
		{ // Unsafe block
			pidxs[pidxs_len] = idx;
			pidxs_len++;
		}
		idx += rep.len;
	}
	if (pidxs_len == 0) {
		string _t3 = builtin__string_clone(s);
			{ // defer begin
				if (pidxs_cap > _const_replace_stack_buffer_size) {
					builtin___v_free(pidxs);
				}
			} // defer end
		return _t3;
	}
	int new_len = (int)(s.len + (int)(pidxs_len * ((int)(with.len - rep.len))));
	u8* b = builtin__malloc_noscan((int)(new_len + 1));
	int b_i = 0;
	int s_idx = 0;
	for (int j = 0; j < pidxs_len; ++j) {
		int rep_pos = pidxs[j];
		int before_len = (int)(rep_pos - s_idx);
		builtin__vmemcpy(&b[b_i], &s.str[s_idx], before_len);
		b_i += before_len;
		s_idx = (int)(rep_pos + rep.len);
		builtin__vmemcpy(&b[b_i], &with.str[0], with.len);
		b_i += with.len;
	}
	if (s_idx < s.len) {
		builtin__vmemcpy(&b[b_i], &s.str[s_idx], (int)(s.len - s_idx));
	}
	{ // Unsafe block
		b[new_len] = 0;
		string _t4 = builtin__tos(b, new_len);
			{ // defer begin
				if (pidxs_cap > _const_replace_stack_buffer_size) {
					builtin___v_free(pidxs);
				}
			} // defer end
		return _t4;
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
VV_LOC bool builtin__string__eq(string s, string a) {
	if (s.str == 0) {
		builtin___v_panic(_S("string.eq(): nil string"));
		VUNREACHABLE();
	}
	if (s.len != a.len) {
		return false;
	}
	{ // Unsafe block
		return builtin__vmemcmp(s.str, a.str, a.len) == 0;
	}
	return 0;
}
VV_LOC bool builtin__string__lt(string s, string a) {
	for (int i = 0; i < s.len; ++i) {
		if (i >= a.len || s.str[ i] > a.str[ i]) {
			return false;
		} else if (s.str[ i] < a.str[ i]) {
			return true;
		}
	}
	if (s.len < a.len) {
		return true;
	}
	return false;
}
VV_LOC string builtin__string__plus(string s, string a) {
	int new_len = (int)(a.len + s.len);
	string res = ((string){.str = builtin__malloc_noscan((int)(new_len + 1)), .len = new_len});
	{ // Unsafe block
		builtin__vmemcpy(res.str, s.str, s.len);
		builtin__vmemcpy(res.str + s.len, a.str, a.len);
	}
	{ // Unsafe block
		res.str[new_len] = 0;
	}
	return res;
}
string builtin__string_substr(string s, int start, int _end) {
	int end = (_end == _const_max_i64 || _end == _const_max_i32 ? (s.len) : (_end));
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (start > end || start > s.len || end > s.len || start < 0 || end < 0) {
			builtin___v_panic(builtin__string__plus(builtin__string__plus(builtin__string__plus(builtin__string__plus(builtin__string__plus(builtin__string__plus(builtin__string__plus(_S("substr("), builtin__impl_i64_to_string(start)), _S(", ")), builtin__impl_i64_to_string(end)), _S(") out of bounds (len=")), builtin__impl_i64_to_string(s.len)), _S(") s=")), s));
			VUNREACHABLE();
		}
	}
	#endif
	int len = (int)(end - start);
	if (len == s.len) {
		return builtin__string_clone(s);
	}
	string res = ((string){.str = builtin__malloc_noscan((int)(len + 1)), .len = len});
	{ // Unsafe block
		builtin__vmemcpy(res.str, s.str + start, len);
		res.str[len] = 0;
	}
	return res;
}
VV_LOC int builtin__string_index_(string s, string p) {
	if (p.len > s.len || p.len == 0) {
		return -1;
	}
	if (p.len > 2) {
		return builtin__string_index_kmp(s, p);
	}
	int i = 0;
	for (;;) {
		if (!(i < s.len)) break;
		int j = 0;
		for (;;) {
			if (!(j < p.len && s.str[(int)(i + j)] == p.str[j])) break;
			j++;
		}
		if (j == p.len) {
			return i;
		}
		i++;
	}
	return -1;
}
VV_LOC int builtin__string_index_kmp(string s, string p) {
	if (p.len > s.len) {
		return -1;
	}
	Array_fixed_int_20 stack_prefixes = {0};
	int* p_prefixes = &stack_prefixes[0];
	if (p.len > _const_kmp_stack_buffer_size) {
		p_prefixes = ((int*)(builtin__vcalloc((int)(p.len * ((int)(sizeof(int)))))));
	}
	int j = 0;
	for (int i = 1; i < p.len; i++) {
		for (;;) {
			if (!(p.str[j] != p.str[i] && j > 0)) break;
			j = p_prefixes[(int)(j - 1)];
		}
		if (p.str[j] == p.str[i]) {
			j++;
		}
		{ // Unsafe block
			p_prefixes[i] = j;
		}
	}
	j = 0;
	for (int i = 0; i < s.len; ++i) {
		for (;;) {
			if (!(p.str[j] != s.str[i] && j > 0)) break;
			j = p_prefixes[(int)(j - 1)];
		}
		if (p.str[j] == s.str[i]) {
			j++;
		}
		if (j == p.len) {
			int _t2 = (int)((int)(i - p.len) + 1);
				{ // defer begin
					if (p.len > _const_kmp_stack_buffer_size) {
						builtin___v_free(p_prefixes);
					}
				} // defer end
			return _t2;
		}
	}
	int _t3 = -1;
		{ // defer begin
			if (p.len > _const_kmp_stack_buffer_size) {
				builtin___v_free(p_prefixes);
			}
		} // defer end
	return _t3;
}
int builtin__string_index_after_(string s, string p, int start) {
	if (p.len > s.len) {
		return -1;
	}
	int strt = start;
	if (start < 0) {
		strt = 0;
	}
	if (start >= s.len) {
		return -1;
	}
	int i = strt;
	for (;;) {
		if (!(i < s.len)) break;
		int j = 0;
		int ii = i;
		for (;;) {
			if (!(j < p.len && s.str[ii] == p.str[j])) break;
			j++;
			ii++;
		}
		if (j == p.len) {
			return i;
		}
		i++;
	}
	return -1;
}
bool builtin__string_contains_u8(string s, u8 x) {
	for (int _t1 = 0; _t1 < s.len; ++_t1) {
		u8 c = s.str[_t1];
		if (x == c) {
			return true;
		}
	}
	return false;
}
bool builtin__string_contains(string s, string substr) {
	if (substr.len == 0) {
		return true;
	}
	if (substr.len == 1) {
		return builtin__string_contains_u8(s, substr.str[0]);
	}
	return builtin__string_index_(s, substr) != -1;
}
VV_LOC string builtin__string_trim_chars(string s, string cutset, TrimMode mode) {
	int pos_left = 0;
	int pos_right = (int)(s.len - 1);
	bool cs_match = true;
	for (;;) {
		if (!(pos_left <= s.len && pos_right >= -1 && cs_match)) break;
		cs_match = false;
		if (mode == TrimMode__trim_left || mode == TrimMode__trim_both) {
			for (int _t1 = 0; _t1 < cutset.len; ++_t1) {
				u8 cs = cutset.str[_t1];
				if (s.str[ pos_left] == cs) {
					pos_left++;
					cs_match = true;
					break;
				}
			}
		}
		if (mode == TrimMode__trim_right || mode == TrimMode__trim_both) {
			for (int _t2 = 0; _t2 < cutset.len; ++_t2) {
				u8 cs = cutset.str[_t2];
				if (s.str[ pos_right] == cs) {
					pos_right--;
					cs_match = true;
					break;
				}
			}
		}
		if (pos_left > pos_right) {
			return _S("");
		}
	}
	return builtin__string_substr(s, pos_left, (int)(pos_right + 1));
}
inline string builtin__string_str(string s) {
	return builtin__string_clone(s);
}
VV_LOC u8 builtin__string_at(string s, int idx) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (idx < 0 || idx >= s.len) {
			builtin__panic_n2(_S("string index out of range(idx,s.len):"), idx, s.len);
			VUNREACHABLE();
		}
	}
	#endif
	return s.str[idx];
}
string builtin__string_all_before(string s, string sub) {
	int pos = builtin__string_index_(s, sub);
	if (pos == -1) {
		return builtin__string_clone(s);
	}
	return builtin__string_substr(s, 0, pos);
}
string builtin__string_all_after(string s, string sub) {
	int pos = builtin__string_index_(s, sub);
	if (pos == -1) {
		return builtin__string_clone(s);
	}
	return builtin__string_substr(s, (int)(pos + sub.len), 2147483647);
}
void main__print_hello_world(void) {
	builtin__println(_S("Hello, World! gg"));
}
// export alias: print_hello_world -> main__print_hello_world
void print_hello_world(void) {
	return main__print_hello_world();
}
int main__sum(int a, int b) {
	return (int)(a + b);
}
// export alias: sum -> main__sum
int sum(int a, int b) {
	return main__sum(a, b);
}
void main__sort_array(Array_int* arr) {
	if (arr->len > 0) { qsort(arr->data, arr->len, arr->element_size, (voidptr)anon_fn_aa4c3c73e99943ac_int_int__bool_274_lambda_wrapper); }
	;
}
// export alias: sort_array -> main__sort_array
void sort_array(Array_int* arr) {
	return main__sort_array(arr);
}
VV_LOC void main__main(void) {
}
void _vinit(int ___argc, voidptr ___argv) {
#if __STDC_HOSTED__ == 1
	signal(11, builtin__v_segmentation_fault_handler);
#endif
	builtin__builtin_init();
	// Initializations of consts for module builtin.closure
	g_closure = ((builtin__closure__Closure){.ClosureMutex = ((builtin__closure__ClosureMutex){E_STRUCT}),.closure_ptr = 0,.closure_get_data = ((void*)0),.closure_cap = 0,.v_page_size = ((int)(0x4000)),}); // global 3
{
{
Array_fixed_u8_15 _t1;
#if defined(__V_amd64)
	{ Array_fixed_u8_15 _t2 = {((u8)(0xF3)), 0x44, 0x0F, 0x7E, 0x3D, 0xF7, 0xBF, 0xFF, 0xFF, 0xFF, 0x25, 0xF9, 0xBF, 0xFF, 0xFF}	;
	memcpy(&_t1, &_t2, sizeof(Array_fixed_u8_15));
	}
	;
#elif defined(__V_x86)
#elif defined(__V_arm64)
#elif defined(__V_arm32)
#elif defined(__V_rv64)
#elif defined(__V_rv32)
#elif defined(__V_s390x)
#elif defined(__V_ppc64le)
#elif defined(__V_loongarch64)
#else
#endif
	memcpy(&_const_builtin__closure__closure_thunk, &_t1, sizeof(Array_fixed_u8_15));
}
}
{
{
Array_fixed_u8_6 _t3;
#if defined(__V_amd64)
	{ Array_fixed_u8_6 _t4 = {((u8)(0x66)), 0x4C, 0x0F, 0x7E, 0xF8, 0xC3}	;
	memcpy(&_t3, &_t4, sizeof(Array_fixed_u8_6));
	}
	;
#elif defined(__V_x86)
#elif defined(__V_arm64)
#elif defined(__V_arm32)
#elif defined(__V_rv64)
#elif defined(__V_rv32)
#elif defined(__V_s390x)
#elif defined(__V_ppc64le)
#elif defined(__V_loongarch64)
#else
#endif
	memcpy(&_const_builtin__closure__closure_get_data_bytes, &_t3, sizeof(Array_fixed_u8_6));
}
}
{
{
	_const_builtin__closure__closure_size_1 = ((u32)(2 * ((u32)(sizeof(voidptr)))) > ((u32)(15)) ? ((u32)(2 * ((u32)(sizeof(voidptr))))) : ((u32)((u32)(((u32)(15)) + ((u32)(sizeof(voidptr)))) - 1)));
}
}
	_const_builtin__closure__closure_size = ((int)((_const_builtin__closure__closure_size_1 & ~((u32)(((u32)(sizeof(voidptr))) - 1)))));
	// Initializations of consts for module builtin
	_const_digit_pairs = _S("00102030405060708090011121314151617181910212223242526272829203132333435363738393041424344454647484940515253545556575859506162636465666768696071727374757677787970818283848586878889809192939495969798999");
	g_live_reload_info = *(voidptr*)&((voidptr[]){0}[0]); // global 5
	_const_min_i64 = ((i64)((int_literal)(-9223372036854775807LL - 1)));
	_const_max_i64 = ((i64)(9223372036854775807LL));
}
void _vcleanup(void) {
}

int main(int ___argc, char** ___argv){
	g_main_argc = ___argc;
	g_main_argv = ___argv;
	_vinit(___argc, (voidptr)___argv);
	main__main();
	_vcleanup();
	return 0;
}
// THE END.
